<!DOCTYPE html> <!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]--> <!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8"><![endif]--> <!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9"><![endif]--> <!--[if gt IE 8]><!--> <html class="no-js"><!--<![endif]--> <head> <meta charset="UTF-8"> <meta content="text/html; charset=UTF-8" http-equiv="Content-Type"> <meta http-equiv=X-UA-Compatible content="IE=edge,chrome=1"> <title>ملاحظات جافا &#8211; موقع ملهم</title> <meta name="description" content="ملاحظات هامة لمبتدئي لغة جافا والفروقات الرئيسية بين بعض أنواع الأصناف (interface classes vs abstract classes..)"> <meta name="keywords" content=""> <!-- Twitter Cards --> <meta name="twitter:card" content="summary"> <meta name="twitter:image" content="http://localhost:4000/assets/img/logo.png"> <meta name="twitter:title" content="ملاحظات جافا"> <meta name="twitter:description" content=" interface class Abtract class ملاحظات متفرقة المراجعinterface classيُعرّف الصنف من هذا النوع على الشكل التالي: public interface Nameتحتوي على دالّات Methods بدون متن body أي فقط تعريف للدالات، مثلًا على الشكل: public boolean add(String s);وهذا النوع من الدالات methods الذي لا يحوي متن body يدعى abstract methodsوبالتالي تكون الدالات من نوع interface عبارة عن مجموعة من التوابع ذات النوع abstract أي collection of abtract methodsيمكن أن تحتوي دالات الـ interface على ثوابت أيضا، أي تعريف متغيرات مع إعطاء قيمهم، وأيضًا توابع رئيسية default methods وتوابع ثابتة static methodsالـ interface class تحل مشكلة التوريث في لغة جافا، حيث أنه غير ممكن لصنف أن يرث من أكثر من صنف آخر، هذا يعني أنه لا يمكن كتابة: public class Name extends name1, name2{ولكن يمكن كتابة: public class Name implements name1, name2{لماذا التوريث غير مسموح في الجافا؟ لعدم حصول مشاكل فعندما يكون لدينا صنف class يرث صنفين في نفس الوقت ويكون بين تلك الأصناف تعارض فلا يمكن تحديد أي دالة أو أمر يجب أن ينفذ الصنف الوارث! وبالتالي لايمكن أن يحدث فيها تعارض ﻷنها لا تحوي تعليمات ضمن التوابع methods.ولكن! الـ interface يمكن أن تحوي constants متغيرات مع قيمهم، ولكن من الأفضل عدم استخدام هذه الميزة لعدم حصول تعارض كما ذكرنا، في حالة التعارض ستظهر compiling errorولن يتم بناء البرنامجوظيفة أصناف ال interface: تعمل بشكل قالب يحدد الوظائف التي يجب أن تكون بالأصناف التابعة.مثال على صنف interface وصنف تابع له public interface ExampleInterface { public void doAction(); public String doThis(int number); } public class sub implements ExampleInterface { public void doAction() { //specify what must happen } public String doThis(int number) { //specfiy what must happen } }Abtract classنفس ال interface ولكن تحوي تعليمات ضمن ال methods، كما لا يمكن إنشاء عنصر object منها، يعني لدينا مثلا صنف student من نوع abtract فـ لايمكن كتابة: Student s = new Student();يمكن للصنف من نوع abstract أن يحوي توابع abstract methods بمتن body أو توابع بدون متن.مثال://abstract classpublic abstract class Person { private String name; private String gender; public Person(String nm, String gen){ this.name=nm; this.gender=gen; } //abstract method public abstract void work(); @Override public String toString(){ return &quot;Name=&quot;+this.name+&quot;::Gender=&quot;+this.gender; } public void changeName(String newName) { this.name = newName; } }مع ملاحظة هنا أن الدالة work من نوع abstract، ودائما عندما يكون لدينا دالة من هذا النوع فالـ class كله يجب أن يكون abstract بشكل إجباريّ، والعكس غير صحيح، أي ليس من الشرط على الـ abstract class أن تحوي abstract methodsومثال للتابع الوريث subclass:package com.journaldev.design;public class Employee extends Person { private int empId; public Employee(String nm, String gen, int id) { super(nm, gen); this.empId=id; } @Override public void work() { if(empId == 0){ System.out.println(&quot;Not working&quot;); }else{ System.out.println(&quot;Working as employee!!&quot;); } } public static void main(String args[]){ //coding in terms of abstract classes Person student = new Employee(&quot;Dove&quot;,&quot;Female&quot;,0); Person employee = new Employee(&quot;Pankaj&quot;,&quot;Male&quot;,123); student.work(); employee.work(); //using method implemented in abstract class - inheritance employee.changeName(&quot;Pankaj Kumar&quot;); System.out.println(employee.toString()); }}الـ subclass يجب أن ينفّذ كل ال abstract methods، أي يعيد كتابتهم وملأهم بالتعليمات، إلّا إذا كان التابع الوارث subclass أيضا abstract class، وهذا هو تقريبا الفرق بين عمل extends لـ abstract class أو صنف عادي.يمكن لل abtract class أن تحوي main methodsوظيفتها تقديم دالات مع أوامرها جاهزة افتراضيًا لاستخدامها بالتوابع الورثة.ملاحظات متفرقةعندما يكون في الكلاس الرئيسي المُوَرِّث superclass دالة رئيسيّة (default method) تتطلب ٢ سترينع (نص) مثلًا، فيجب أن نكتب في أول سطر في الـدالة الرئيسية في الـتابع الوارث Subclaase دالة ()super، مثال: super(&quot;a&quot;, &quot;b&quot;);الدالات من نوع static بامكاننا أن نستدعيها من صنف آخر بدون انشاء عنصر من الصنف، أي بدلًا من كتابة:Student s = new Student();s.hawa();نكتب: Student.hawa();المتغيرات من نوع final لايمكننا تغيير قيمتهاهل لديك سؤال أو معلومة إضافية؟ يرجى مشاركتنا إياها في التعليقات لإضافتها للنص الأصليالمراجع Stackoverflow Quora stackoverflow journaldev"> <!-- Open Graph --> <meta property="og:locale" content="ar_SY"> <meta property="og:type" content="article"> <meta property="og:title" content="ملاحظات جافا"> <meta property="og:description" content=" interface class Abtract class ملاحظات متفرقة المراجعinterface classيُعرّف الصنف من هذا النوع على الشكل التالي: public interface Nameتحتوي على دالّات Methods بدون متن body أي فقط تعريف للدالات، مثلًا على الشكل: public boolean add(String s);وهذا النوع من الدالات methods الذي لا يحوي متن body يدعى abstract methodsوبالتالي تكون الدالات من نوع interface عبارة عن مجموعة من التوابع ذات النوع abstract أي collection of abtract methodsيمكن أن تحتوي دالات الـ interface على ثوابت أيضا، أي تعريف متغيرات مع إعطاء قيمهم، وأيضًا توابع رئيسية default methods وتوابع ثابتة static methodsالـ interface class تحل مشكلة التوريث في لغة جافا، حيث أنه غير ممكن لصنف أن يرث من أكثر من صنف آخر، هذا يعني أنه لا يمكن كتابة: public class Name extends name1, name2{ولكن يمكن كتابة: public class Name implements name1, name2{لماذا التوريث غير مسموح في الجافا؟ لعدم حصول مشاكل فعندما يكون لدينا صنف class يرث صنفين في نفس الوقت ويكون بين تلك الأصناف تعارض فلا يمكن تحديد أي دالة أو أمر يجب أن ينفذ الصنف الوارث! وبالتالي لايمكن أن يحدث فيها تعارض ﻷنها لا تحوي تعليمات ضمن التوابع methods.ولكن! الـ interface يمكن أن تحوي constants متغيرات مع قيمهم، ولكن من الأفضل عدم استخدام هذه الميزة لعدم حصول تعارض كما ذكرنا، في حالة التعارض ستظهر compiling errorولن يتم بناء البرنامجوظيفة أصناف ال interface: تعمل بشكل قالب يحدد الوظائف التي يجب أن تكون بالأصناف التابعة.مثال على صنف interface وصنف تابع له public interface ExampleInterface { public void doAction(); public String doThis(int number); } public class sub implements ExampleInterface { public void doAction() { //specify what must happen } public String doThis(int number) { //specfiy what must happen } }Abtract classنفس ال interface ولكن تحوي تعليمات ضمن ال methods، كما لا يمكن إنشاء عنصر object منها، يعني لدينا مثلا صنف student من نوع abtract فـ لايمكن كتابة: Student s = new Student();يمكن للصنف من نوع abstract أن يحوي توابع abstract methods بمتن body أو توابع بدون متن.مثال://abstract classpublic abstract class Person { private String name; private String gender; public Person(String nm, String gen){ this.name=nm; this.gender=gen; } //abstract method public abstract void work(); @Override public String toString(){ return &quot;Name=&quot;+this.name+&quot;::Gender=&quot;+this.gender; } public void changeName(String newName) { this.name = newName; } }مع ملاحظة هنا أن الدالة work من نوع abstract، ودائما عندما يكون لدينا دالة من هذا النوع فالـ class كله يجب أن يكون abstract بشكل إجباريّ، والعكس غير صحيح، أي ليس من الشرط على الـ abstract class أن تحوي abstract methodsومثال للتابع الوريث subclass:package com.journaldev.design;public class Employee extends Person { private int empId; public Employee(String nm, String gen, int id) { super(nm, gen); this.empId=id; } @Override public void work() { if(empId == 0){ System.out.println(&quot;Not working&quot;); }else{ System.out.println(&quot;Working as employee!!&quot;); } } public static void main(String args[]){ //coding in terms of abstract classes Person student = new Employee(&quot;Dove&quot;,&quot;Female&quot;,0); Person employee = new Employee(&quot;Pankaj&quot;,&quot;Male&quot;,123); student.work(); employee.work(); //using method implemented in abstract class - inheritance employee.changeName(&quot;Pankaj Kumar&quot;); System.out.println(employee.toString()); }}الـ subclass يجب أن ينفّذ كل ال abstract methods، أي يعيد كتابتهم وملأهم بالتعليمات، إلّا إذا كان التابع الوارث subclass أيضا abstract class، وهذا هو تقريبا الفرق بين عمل extends لـ abstract class أو صنف عادي.يمكن لل abtract class أن تحوي main methodsوظيفتها تقديم دالات مع أوامرها جاهزة افتراضيًا لاستخدامها بالتوابع الورثة.ملاحظات متفرقةعندما يكون في الكلاس الرئيسي المُوَرِّث superclass دالة رئيسيّة (default method) تتطلب ٢ سترينع (نص) مثلًا، فيجب أن نكتب في أول سطر في الـدالة الرئيسية في الـتابع الوارث Subclaase دالة ()super، مثال: super(&quot;a&quot;, &quot;b&quot;);الدالات من نوع static بامكاننا أن نستدعيها من صنف آخر بدون انشاء عنصر من الصنف، أي بدلًا من كتابة:Student s = new Student();s.hawa();نكتب: Student.hawa();المتغيرات من نوع final لايمكننا تغيير قيمتهاهل لديك سؤال أو معلومة إضافية؟ يرجى مشاركتنا إياها في التعليقات لإضافتها للنص الأصليالمراجع Stackoverflow Quora stackoverflow journaldev"> <meta property="og:url" content="http://localhost:4000/Java-notes/"> <meta property="og:site_name" content="موقع ملهم"> <meta property="og:image" content="http://localhost:4000/assets/img/logo.png"> <script> var host = "mulham.github.io"; if ((host == window.location.host) && (window.location.protocol != "https:")) window.location.protocol = "https"; </script> <meta name="yandex-verification" content="ea5684dc21acccc9" /> <link rel="canonical" href="http://localhost:4000/Java-notes/"> <link href="http://localhost:4000/feed.xml" type="application/atom+xml" rel="alternate" title="موقع ملهم Feed"> <!-- Handheld --> <meta name="HandheldFriendly" content="True"> <meta name="MobileOptimized" content="320"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <!-- CSS --> <link rel="stylesheet" href="http://localhost:4000/assets/css/main.css"> <!-- JS --> <script src="http://localhost:4000/assets/js/modernizr-3.3.1.custom.min.js"></script> <!-- Favicons --> <link rel="apple-touch-icon" href="http://localhost:4000/assets/img/favicons/apple-icon-precomposed.png"> <link rel="apple-touch-icon" sizes="72x72" href="http://localhost:4000/assets/img/favicons/apple-icon-72x72.png"> <link rel="apple-touch-icon" sizes="114x114" href="http://localhost:4000/assets/img/favicons/apple-icon-114x114.png"> <link rel="apple-touch-icon" sizes="144x144" href="http://localhost:4000/assets/img/favicons/apple-icon-144x144.png"> <link rel="shortcut icon" type="image/png" href="http://localhost:4000/favicon.png" /> <link rel="shortcut icon" href="http://localhost:4000/favicon.ico" /> <!-- Background Image --> <style type="text/css">body {background-image:url(http://localhost:4000/assets/img/placeholder-big.jpg); background-repeat: no-repeat; background-size: cover; }</style> <!-- Post Feature Image --> </head> <body> <nav id="dl-menu" class="dl-menuwrapper" role="navigation"> <button class="dl-trigger">عرض القائمة</button> <ul class="dl-menu"> <li><a href="http://localhost:4000/">الرئيسيّة</a></li> <li> <a href="#">عن الموقع</a> <ul class="dl-submenu"> <li> <img src="http://localhost:4000/assets/img/logo.png" alt="موقع ملهم photo" class="author-photo"> <h4>موقع ملهم</h4> <p>شغف المعرفة</p> </li> <li><a href="http://localhost:4000/about/"><span class="btn btn-inverse">تعرّف أكثر</span></a></li> <li> <a href="mailto:mulham94@gmail.com" target="_blank" rel="noopener noreferrer"><i class="fa fa-fw fa-envelope-square"></i> البريد الإلكتروني</a> </li> <li> <a href="http://github.com/mulham" target="_blank" rel="noopener noreferrer"><i class="fa fa-fw fa-github"></i> Github</a> </li> <li> <a href="https://youtube.com/user/mulham94" target="_blank" rel="noopener noreferrer"><i class="fa fa-fw fa-youtube-square"></i> يوتيوب</a> </li> </ul><!-- /.dl-submenu --> </li> <li> <a href="http://localhost:4000/posts/">المدونة</a> </li> <li><a href="http://localhost:4000/tutorials/" >الدروس</a></li> <li><a href="http://localhost:4000/urls" >روابط مفيدة</a></li> </ul><!-- /.dl-menu --> </nav><!-- /.dl-menuwrapper --> <!-- Header --> <header class="header" role="banner"> <div class="wrapper animated fadeIn"> <div class="content"> <div class="post-title "> <h1>ملاحظات جافا</h1> <h4>20 May 2019</h4> <p class="reading-time"> <i class="fa fa-clock-o"></i> مدة القراءة ~ 3 دقائق </p><!-- /.entry-reading-time --> <a class="btn zoombtn" href="http://localhost:4000/tutorials/"> <i class="fa fa-chevron-left"></i> </a> </div> <ul id="markdown-toc"> <li><a href="#interface-class" id="markdown-toc-interface-class">interface class</a></li> <li><a href="#abtract-class" id="markdown-toc-abtract-class">Abtract class</a></li> <li><a href="#ملاحظات-متفرقة" id="markdown-toc-ملاحظات-متفرقة">ملاحظات متفرقة</a></li> <li><a href="#المراجع" id="markdown-toc-المراجع">المراجع</a></li> </ul> <h1 id="interface-class">interface class</h1> <p>يُعرّف الصنف من هذا النوع على الشكل التالي:</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	public interface Name
 <p>تحتوي على دالّات Methods بدون متن body أي فقط تعريف للدالات، مثلًا على الشكل:</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	public boolean add(String s);
</code></pre></div></div> <p>وهذا النوع من الدالات methods الذي لا يحوي متن body يدعى abstract methods</p> <p>وبالتالي تكون الدالات من نوع interface عبارة عن مجموعة من التوابع ذات النوع abstract أي collection of abtract methods</p> <p>يمكن أن تحتوي دالات الـ interface على ثوابت أيضا، أي تعريف متغيرات مع إعطاء قيمهم، وأيضًا توابع رئيسية default methods وتوابع ثابتة static methods</p> <p>الـ interface class تحل مشكلة التوريث في لغة جافا، حيث أنه غير ممكن لصنف أن يرث من أكثر من صنف آخر، هذا يعني أنه <strong>لا</strong> يمكن كتابة:</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	public class Name extends name1, name2{
</code></pre></div></div> <p>ولكن <strong>يمكن</strong> كتابة:</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	public class Name implements name1, name2{
</code></pre></div></div> <p>لماذا التوريث غير مسموح في الجافا؟ لعدم حصول مشاكل فعندما يكون لدينا صنف class يرث صنفين في نفس الوقت ويكون بين تلك الأصناف تعارض فلا يمكن تحديد أي دالة أو أمر يجب أن ينفذ الصنف الوارث! وبالتالي لايمكن أن يحدث فيها تعارض ﻷنها لا تحوي تعليمات ضمن التوابع methods.</p> <p>ولكن! الـ interface يمكن أن تحوي constants متغيرات مع قيمهم، ولكن من الأفضل عدم استخدام هذه الميزة لعدم حصول تعارض كما ذكرنا، في حالة التعارض ستظهر compiling error ولن يتم بناء البرنامج</p> <p>وظيفة أصناف ال interface: تعمل بشكل قالب يحدد الوظائف التي يجب أن تكون بالأصناف التابعة.</p> <p>مثال على صنف interface وصنف تابع له</p> <figure class="highlight"><pre><code class="language-java" data-lang="java"> <span class="kd">public</span> <span class="kd">interface</span> <span class="nc">ExampleInterface</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">doAction</span><span class="o">();</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">doThis</span><span class="o">(</span><span class="kt">int</span> <span class="n">number</span><span class="o">);</span>
 <span class="o">}</span>

 <span class="kd">public</span> <span class="kd">class</span> <span class="nc">sub</span> <span class="kd">implements</span> <span class="n">ExampleInterface</span> <span class="o">{</span>
     <span class="kd">public</span> <span class="kt">void</span> <span class="nf">doAction</span><span class="o">()</span> <span class="o">{</span>
       <span class="c1">//specify what must happen</span>
     <span class="o">}</span>

     <span class="kd">public</span> <span class="n">String</span> <span class="nf">doThis</span><span class="o">(</span><span class="kt">int</span> <span class="n">number</span><span class="o">)</span> <span class="o">{</span>
       <span class="c1">//specfiy what must happen</span>
     <span class="o">}</span>
 <span class="o">}</span></code></pre></figure> <hr> <h1 id="abtract-class">Abtract class</h1> <p>نفس ال interface ولكن تحوي تعليمات ضمن ال methods، كما لا يمكن إنشاء عنصر object منها، يعني لدينا مثلا صنف student من نوع abtract فـ <strong>لايمكن</strong> كتابة:</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	Student s = new Student();
</code></pre></div></div> <p>يمكن للصنف من نوع abstract أن يحوي توابع abstract methods بمتن body أو توابع بدون متن.</p> <p>مثال:</p> <figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">//abstract class</span>
<span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>
	
	<span class="kd">private</span> <span class="n">String</span> <span class="n">name</span><span class="o">;</span>
	<span class="kd">private</span> <span class="n">String</span> <span class="n">gender</span><span class="o">;</span>
	
	<span class="kd">public</span> <span class="nf">Person</span><span class="o">(</span><span class="n">String</span> <span class="n">nm</span><span class="o">,</span> <span class="n">String</span> <span class="n">gen</span><span class="o">){</span>
		<span class="k">this</span><span class="o">.</span><span class="na">name</span><span class="o">=</span><span class="n">nm</span><span class="o">;</span>
		<span class="k">this</span><span class="o">.</span><span class="na">gender</span><span class="o">=</span><span class="n">gen</span><span class="o">;</span>
	<span class="o">}</span>
	
	<span class="c1">//abstract method</span>
	<span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">work</span><span class="o">();</span>
	
	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="n">String</span> <span class="nf">toString</span><span class="o">(){</span>
		<span class="k">return</span> <span class="s">"Name="</span><span class="o">+</span><span class="k">this</span><span class="o">.</span><span class="na">name</span><span class="o">+</span><span class="s">"::Gender="</span><span class="o">+</span><span class="k">this</span><span class="o">.</span><span class="na">gender</span><span class="o">;</span>
	<span class="o">}</span>

	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">changeName</span><span class="o">(</span><span class="n">String</span> <span class="n">newName</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">newName</span><span class="o">;</span>
	<span class="o">}</span>	
<span class="o">}</span></code></pre></figure> <p>مع ملاحظة هنا أن الدالة work من نوع abstract، ودائما عندما يكون لدينا دالة من هذا النوع فالـ class كله يجب أن يكون abstract بشكل إجباريّ، والعكس غير صحيح، أي ليس من الشرط على الـ abstract class أن تحوي abstract methods</p> <p>ومثال للتابع الوريث subclass:</p> <figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">journaldev</span><span class="o">.</span><span class="na">design</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Employee</span> <span class="kd">extends</span> <span class="n">Person</span> <span class="o">{</span>
	
	<span class="kd">private</span> <span class="kt">int</span> <span class="n">empId</span><span class="o">;</span>
	
	<span class="kd">public</span> <span class="nf">Employee</span><span class="o">(</span><span class="n">String</span> <span class="n">nm</span><span class="o">,</span> <span class="n">String</span> <span class="n">gen</span><span class="o">,</span> <span class="kt">int</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
		<span class="kd">super</span><span class="o">(</span><span class="n">nm</span><span class="o">,</span> <span class="n">gen</span><span class="o">);</span>
		<span class="k">this</span><span class="o">.</span><span class="na">empId</span><span class="o">=</span><span class="n">id</span><span class="o">;</span>
	<span class="o">}</span>

	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">work</span><span class="o">()</span> <span class="o">{</span>
		<span class="k">if</span><span class="o">(</span><span class="n">empId</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
			<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Not working"</span><span class="o">);</span>
		<span class="o">}</span><span class="k">else</span><span class="o">{</span>
			<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Working as employee!!"</span><span class="o">);</span>
		<span class="o">}</span>
	<span class="o">}</span>
	
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span> <span class="n">args</span><span class="o">[]){</span>
		<span class="c1">//coding in terms of abstract classes</span>
		<span class="n">Person</span> <span class="n">student</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Employee</span><span class="o">(</span><span class="s">"Dove"</span><span class="o">,</span><span class="s">"Female"</span><span class="o">,</span><span class="mi">0</span><span class="o">);</span>
		<span class="n">Person</span> <span class="n">employee</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Employee</span><span class="o">(</span><span class="s">"Pankaj"</span><span class="o">,</span><span class="s">"Male"</span><span class="o">,</span><span class="mi">123</span><span class="o">);</span>
		<span class="n">student</span><span class="o">.</span><span class="na">work</span><span class="o">();</span>
		<span class="n">employee</span><span class="o">.</span><span class="na">work</span><span class="o">();</span>
		<span class="c1">//using method implemented in abstract class - inheritance</span>
		<span class="n">employee</span><span class="o">.</span><span class="na">changeName</span><span class="o">(</span><span class="s">"Pankaj Kumar"</span><span class="o">);</span>
		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">employee</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
	<span class="o">}</span>

<span class="o">}</span></code></pre></figure> <p>الـ subclass <strong>يجب أن</strong> ينفّذ كل ال abstract methods، أي يعيد كتابتهم وملأهم بالتعليمات، إلّا إذا كان التابع الوارث subclass أيضا abstract class، وهذا هو تقريبا الفرق بين عمل extends لـ abstract class أو صنف عادي.</p> <p>يمكن لل abtract class أن تحوي main methods</p> <p>وظيفتها تقديم دالات مع أوامرها جاهزة افتراضيًا لاستخدامها بالتوابع الورثة.</p> <h1 id="ملاحظات-متفرقة">ملاحظات متفرقة</h1> <p>عندما يكون في الكلاس الرئيسي المُوَرِّث superclass دالة رئيسيّة (default method) تتطلب ٢ سترينع (نص) مثلًا، فيجب أن نكتب في أول سطر في الـدالة الرئيسية في الـتابع الوارث Subclaase دالة ()super، مثال:</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	super("a", "b");
</code></pre></div></div> <p>الدالات من نوع static بامكاننا أن نستدعيها من صنف آخر بدون انشاء عنصر من الصنف، أي بدلًا من كتابة:</p> <figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">Student</span> <span class="n">s</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Student</span><span class="o">();</span>
<span class="n">s</span><span class="o">.</span><span class="na">hawa</span><span class="o">();</span></code></pre></figure> <p>نكتب:</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	Student.hawa();
</code></pre></div></div> <p>المتغيرات من نوع final لايمكننا تغيير قيمتها</p> <hr> <p>هل لديك سؤال أو معلومة إضافية؟ يرجى مشاركتنا إياها في التعليقات لإضافتها للنص الأصلي</p> <h1 id="المراجع">المراجع</h1> <ul> <li> <p><a href="https://stackoverflow.com/questions/10839131/implements-vs-extends-when-to-use-whats-the-difference">Stackoverflow</a></p> </li> <li> <p><a href="https://www.quora.com/What-is-the-need-of-interface-in-Java">Quora</a></p> </li> <li><a href="https://stackoverflow.com/questions/8064322/what-is-difference-to-extend-abstract-class-and-non-abstract-class">stackoverflow</a></li> <li><a href="https://www.journaldev.com/1582/abstract-class-in-java">journaldev</a></li> </ul> <div class="entry-meta"> <br> <hr> <span class="entry-tags"></span> <span class="social-share"> <a href="https://www.facebook.com/sharer/sharer.php?u=http://localhost:4000/Java-notes/" title="Share on Facebook" class="tag"> <span class="term"><i class="fa fa-facebook-square"></i> Like</span> </a> <a href="https://twitter.com/intent/tweet?text=http://localhost:4000/Java-notes/" title="Share on Twitter" class="tag"> <span class="term"><i class="fa fa-twitter-square"></i> Tweet</span> </a> <a href="https://plus.google.com/share?url=http://localhost:4000/Java-notes/" title="Share on Google+" class="tag"> <span class="term"><i class="fa fa-google-plus-square"></i> +1</span> </a> </span> <div style="clear:both"></div> </div>   <section id="disqus_thread" class="animated fadeInUp"></section><!-- /#disqus_thread -->  <!-- JS --> <script src="http://localhost:4000/assets/js/jquery-1.12.0.min.js"></script> <script src="http://localhost:4000/assets/js/jquery.dlmenu.min.js"></script> <script src="http://localhost:4000/assets/js/jquery.goup.min.js"></script> <script src="http://localhost:4000/assets/js/jquery.magnific-popup.min.js"></script> <script src="http://localhost:4000/assets/js/jquery.fitvid.min.js"></script> <script src="http://localhost:4000/assets/js/scripts.js"></script> <!-- Asynchronous Google Analytics snippet --> <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','//www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-80564042-1', 'auto'); ga('require', 'linkid', 'linkid.js'); ga('send', 'pageview'); </script> <script type="text/javascript"> var disqus_shortname = 'mulham-1'; (function() { var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true; dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js'; (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq); })(); (function () { var s = document.createElement('script'); s.async = true; s.type = 'text/javascript'; s.src = '//' + disqus_shortname + '.disqus.com/count.js'; (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s); }()); </script> <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a>
</noscript> <!-- MathJax --> <script async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> </body> </html>
